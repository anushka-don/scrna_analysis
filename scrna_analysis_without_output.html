<html>
<head>
<title>scrna_analysis.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
.ls0 { height: 1px; border-width: 0; color: #dfe1e5; background-color:#dfe1e5}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scrna_analysis.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% md 
</span><span class="s1"># Single cell transcriptomic analyses implicate an immunosuppressive tumor microenvironment in pancreatic cancer liver metastasis <hr class="ls0"></span><span class="s0">#%% 
# import libraries</span>
<span class="s2">import </span><span class="s1">scanpy </span><span class="s2">as </span><span class="s1">sc</span>
<span class="s2">import </span><span class="s1">anndata </span><span class="s2">as </span><span class="s1">ad</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">seaborn </span><span class="s2">as </span><span class="s1">sns</span>
<span class="s2">import </span><span class="s1">scrublet </span><span class="s2">as </span><span class="s1">scr</span>
<span class="s2">import </span><span class="s1">harmonypy </span><span class="s2">as </span><span class="s1">hm</span>
<span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s2">import </span><span class="s1">celltypist</span>
<span class="s2">from </span><span class="s1">celltypist </span><span class="s2">import </span><span class="s1">models</span>
<span class="s2">from </span><span class="s1">cellphonedb.src.core.methods </span><span class="s2">import </span><span class="s1">cpdb_analysis_method</span>
<span class="s2">import </span><span class="s1">scvelo </span><span class="s2">as </span><span class="s1">scv</span>
<span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s2">from </span><span class="s1">sccoda.util </span><span class="s2">import </span><span class="s1">cell_composition_data </span><span class="s2">as </span><span class="s1">dat</span>
<span class="s2">from </span><span class="s1">sccoda.util </span><span class="s2">import </span><span class="s1">data_visualization </span><span class="s2">as </span><span class="s1">viz</span>
<span class="s2">import </span><span class="s1">sccoda.model </span><span class="s2">as </span><span class="s1">model</span>
<span class="s2">from </span><span class="s1">sccoda.util </span><span class="s2">import </span><span class="s1">comp_ana </span><span class="s2">as </span><span class="s1">mod</span>
<span class="s2">import </span><span class="s1">arviz </span><span class="s2">as </span><span class="s1">az</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">%matplotlib inline</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">## QC <hr class="ls0"></span><span class="s0">#%% 
# Read all sample folders</span>
<span class="s1">sample_paths = {</span><span class="s3">'case1_yf' </span><span class="s1">: </span><span class="s3">'samples/GSM5910784_Case1-YF'</span><span class="s1">,</span>
<span class="s3">'case1_zy'</span><span class="s1">: </span><span class="s3">'samples/GSM5910785_Case1-ZY'</span><span class="s1">,</span>
<span class="s3">'case2_zc'</span><span class="s1">: </span><span class="s3">'samples/GSM5910786_Case2-ZC'</span><span class="s1">,</span>
<span class="s3">'case2_yf'</span><span class="s1">:</span><span class="s3">'samples/GSM5910787_Case2-YF'</span><span class="s1">,</span>
<span class="s3">'case2_zy'</span><span class="s1">: </span><span class="s3">'samples/GSM5910788_Case2-ZY'</span><span class="s1">,</span>
<span class="s3">'case3_yf'</span><span class="s1">: </span><span class="s3">'samples/GSM5910789_Case3-YF'</span><span class="s1">,</span>
<span class="s3">'case3_zy'</span><span class="s1">: </span><span class="s3">'samples/GSM5910790_Case3-ZY'</span><span class="s1">,</span>
<span class="s3">'case4_zy'</span><span class="s1">: </span><span class="s3">'samples/GSM5910791_Case4-ZY'</span><span class="s1">}</span><hr class="ls0"><span class="s0">#%% 
# Read the folders with sc package { sample: anndata,..}</span>
<span class="s0"># ref - https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html</span>
<span class="s1">adatas = {}</span>

<span class="s2">for </span><span class="s1">name, folder </span><span class="s2">in </span><span class="s1">sample_paths.items():</span>
    <span class="s1">sample_adata = sc.read_10x_mtx(folder)</span>
    <span class="s1">sample_adata.var_names_make_unique()</span>
    <span class="s1">adatas[name] = sample_adata</span>

<span class="s1">adata = ad.concat(adatas, label=</span><span class="s3">&quot;sample&quot;</span><span class="s1">)</span>
<span class="s1">adata.var_names_make_unique()</span>
<span class="s1">adata.obs_names_make_unique()</span>
<span class="s1">print(adata.obs[</span><span class="s3">&quot;sample&quot;</span><span class="s1">].value_counts())</span>
<span class="s1">adata</span><hr class="ls0"><span class="s0">#%% 
# Sample anndata</span>
<span class="s1">adatas[</span><span class="s3">'case1_yf'</span><span class="s1">]</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">#### Minimum information on the number of unique genes detected per barcode, the total number of molecules per barcode, and the percentage of reads that map to the mitochondrial genome. <hr class="ls0"></span><span class="s0">#%% 
#For each sample, add everything to the dataframe</span>
<span class="s1">qc_all = []</span>
<span class="s2">for </span><span class="s1">sample </span><span class="s2">in </span><span class="s1">sample_paths.keys():</span>
    <span class="s1">adata = adatas[sample]</span>

    <span class="s0"># Sort the varnames into mt, rb and hb genes</span>
    <span class="s1">adata.var[</span><span class="s3">&quot;mt&quot;</span><span class="s1">] = adata.var_names.str.startswith(</span><span class="s3">&quot;MT-&quot;</span><span class="s1">)</span>
    <span class="s1">adata.var[</span><span class="s3">&quot;ribo&quot;</span><span class="s1">] = adata.var_names.str.startswith((</span><span class="s3">&quot;RPS&quot;</span><span class="s1">, </span><span class="s3">&quot;RPL&quot;</span><span class="s1">))</span>
    <span class="s1">adata.var[</span><span class="s3">&quot;hb&quot;</span><span class="s1">] = adata.var_names.str.contains(</span><span class="s3">&quot;^HB[^(P)]&quot;</span><span class="s1">)</span>

    <span class="s0"># QC metrics</span>
    <span class="s1">adata.obs[</span><span class="s3">'n_genes'</span><span class="s1">] = (adata.X &gt; </span><span class="s4">0</span><span class="s1">).sum(axis=</span><span class="s4">1</span><span class="s1">).A1</span>
    <span class="s1">adata.obs[</span><span class="s3">'n_counts'</span><span class="s1">] = adata.X.sum(axis=</span><span class="s4">1</span><span class="s1">).A1</span>
    <span class="s1">mito_genes = adata.var_names.str.upper().str.startswith(</span><span class="s3">'MT-'</span><span class="s1">)</span>
    <span class="s1">adata.obs[</span><span class="s3">'percent_mito'</span><span class="s1">] = (</span>
        <span class="s1">adata[:, mito_genes].X.sum(axis=</span><span class="s4">1</span><span class="s1">).A1 / adata.obs[</span><span class="s3">'n_counts'</span><span class="s1">]</span>
    <span class="s1">) * </span><span class="s4">100</span>

    <span class="s0"># Add sample name as a column for plotting</span>
    <span class="s1">adata.obs[</span><span class="s3">'sample'</span><span class="s1">] = sample</span>

    <span class="s0"># Store for combined plotting or export</span>
    <span class="s1">qc_all.append(adata.obs)</span>

<span class="s0"># Combine all samples into one DataFrame</span>
<span class="s1">qc_df = pd.concat(qc_all)</span>

<span class="s0"># Now you can inspect or plot:</span>
<span class="s1">qc_df</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">#### integrated plot that visualizes the above metrics jointly for each sample. <hr class="ls0"></span><span class="s0">#%% 
# Violin plots</span>

<span class="s2">for </span><span class="s1">sample </span><span class="s2">in </span><span class="s1">sample_paths.keys():</span>
    <span class="s1">adata = adatas[sample]</span>
    <span class="s1">print(sample)</span>
    <span class="s1">sc.pl.violin(</span>
    <span class="s1">adata,</span>
    <span class="s1">[</span><span class="s3">&quot;n_genes&quot;</span><span class="s1">, </span><span class="s3">&quot;n_counts&quot;</span><span class="s1">, </span><span class="s3">&quot;percent_mito&quot;</span><span class="s1">],</span>
    <span class="s1">jitter=</span><span class="s4">0.4</span><span class="s1">,</span>
    <span class="s1">multi_panel=</span><span class="s2">True</span><span class="s1">,</span>
<span class="s1">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">#### Double detection tool <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">summary = []</span>
<span class="s1">temp = []</span>
<span class="s2">for </span><span class="s1">sample </span><span class="s2">in </span><span class="s1">sample_paths.keys():</span>
    <span class="s1">print(sample)</span>
    <span class="s1">adata = adatas[sample]</span>

    <span class="s0"># Record before filtering</span>
    <span class="s1">pre_cells = adata.n_obs</span>
    <span class="s1">pre_genes = adata.n_vars</span>

    <span class="s0"># Filtering</span>
    <span class="s1">sc.pp.filter_cells(adata, min_genes=</span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">sc.pp.filter_genes(adata, min_cells=</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s0"># Doublet detection</span>
    <span class="s1">scrub = scr.Scrublet(adata.X)</span>
    <span class="s1">doublet_scores, predicted_doublets = scrub.scrub_doublets()</span>
    <span class="s1">adata.obs[</span><span class="s3">'doublet_score'</span><span class="s1">] = doublet_scores</span>
    <span class="s1">adata.obs[</span><span class="s3">'predicted_doublet'</span><span class="s1">] = predicted_doublets</span>

    <span class="s0"># Record after filtering</span>
    <span class="s1">post_cells = adata.n_obs</span>
    <span class="s1">post_genes = adata.n_vars</span>

    <span class="s0"># Save info for summary table</span>
    <span class="s1">summary.append({</span>
        <span class="s3">'sample'</span><span class="s1">: sample,</span>
        <span class="s3">'cells_pre'</span><span class="s1">: pre_cells,</span>
        <span class="s3">'genes_pre'</span><span class="s1">: pre_genes,</span>
        <span class="s3">'cells_post'</span><span class="s1">: post_cells,</span>
        <span class="s3">'genes_post'</span><span class="s1">: post_genes,</span>
        <span class="s3">'n_doublets'</span><span class="s1">: predicted_doublets.sum()</span>
    <span class="s1">})</span>
<hr class="ls0"><span class="s0">#%% 
</span><span class="s1">summary_df = pd.DataFrame(summary)</span>
<span class="s1">summary_df</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### Filtering Thresholds and Justification 
For this analysis, I applied quality control (QC) filtering thresholds commonly used in single-cell RNA sequencing (scRNA-seq) preprocessing. Specifically, I filtered: 
Cells with fewer than 100 detected genes, to exclude low-complexity droplets likely containing ambient RNA or debris. 
Genes not detected in at least 3 cells, to remove uninformative or noise-level features. <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">### Pre- and Post-Filtering Cell and Gene Counts 
Answered above <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">### what are some potential strategies to set thresholds that don’t rely on visual inspection of plots? 
We can remove genes that are do not show a variation in expression, or remove genes with more than 10 % NaN values. That will allow us to retain high quality data without visual inspection <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Normalization <hr class="ls0"></span><span class="s0">#%% 
# Concat adatas into adata</span>
<span class="s1">adata = ad.concat(adatas, join=</span><span class="s3">'outer'</span><span class="s1">, label=</span><span class="s3">'sample'</span><span class="s1">)</span>
<span class="s1">adata.obs_names_make_unique()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata_celltypist = adata.copy()</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">Normalize total counts per cell: Each cell's total count is scaled to a target of 10,000. This step adjusts for sequencing depth and technical differences between cells. 
 
Logarithmic transformation (log1p): Applies a log-transformation to stabilized variance, using the formula log(x + 1), which helps downstream methods like PCA and clustering by reducing the influence of highly expressed genes. <hr class="ls0"></span><span class="s0">#%% 
# Normalize total counts to 10,000 per cell</span>
<span class="s1">sc.pp.normalize_total(adata, target_sum=</span><span class="s4">1e4</span><span class="s1">)</span>

<span class="s0"># Logarithmic transformation</span>
<span class="s1">sc.pp.log1p(adata)</span>
<hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">Cool notes: 
pp is preprocessing. 
tl is tools. 
pl is for plotting. 
Scanpy is a very organized library. <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Feature Selection <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">We used the 'seurat_v3' method for identifying highly variable genes, which models the variance as a function of mean expression using regularized negative binomial models. <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">sc.pp.highly_variable_genes(adata, flavor=</span><span class="s3">&quot;seurat_v3&quot;</span><span class="s1">, n_top_genes=</span><span class="s4">10000</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# Plot highly variable genes</span>
<span class="s1">sc.pl.highly_variable_genes(adata)</span>
<hr class="ls0"><span class="s0">#%% 
</span><span class="s1">n_hvg = adata.var[</span><span class="s3">'highly_variable'</span><span class="s1">].sum()</span>
<span class="s1">n_nonhvg = (~adata.var[</span><span class="s3">'highly_variable'</span><span class="s1">]).sum()</span>
<span class="s1">print(</span><span class="s3">f&quot;Highly variable genes: </span><span class="s5">{</span><span class="s1">n_hvg</span><span class="s5">}</span><span class="s3">, Non-variable genes: </span><span class="s5">{</span><span class="s1">n_nonhvg</span><span class="s5">}</span><span class="s3">&quot;</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### PCA <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">adata.obs_names_make_unique()</span>
<span class="s1">adata = adata[:, adata.var[</span><span class="s3">'highly_variable'</span><span class="s1">]].copy()</span>

<span class="s0"># Scale data and run PCA</span>
<span class="s1">sc.pp.scale(adata, max_value=</span><span class="s4">10</span><span class="s1">)</span>
<span class="s1">sc.tl.pca(adata, svd_solver=</span><span class="s3">'arpack'</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% 
# Plot PCA</span>
<span class="s1">sc.pl.pca(adata, color=</span><span class="s3">'sample'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# Elbow plot</span>
<span class="s1">sc.pl.pca_variance_ratio(adata, log=</span><span class="s2">True</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### UMAP <hr class="ls0"></span><span class="s0">#%% 
# Find neighbours and cludter by leiden clustering</span>
<span class="s1">sc.pp.neighbors(adata, n_neighbors=</span><span class="s4">10</span><span class="s1">, n_pcs=</span><span class="s4">20</span><span class="s1">)</span>
<span class="s1">sc.tl.leiden(adata, resolution=</span><span class="s4">0.5</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.tl.umap(adata)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.umap(adata, color=</span><span class="s3">'leiden'</span><span class="s1">, title=</span><span class="s3">'UMAP Clusters (Leiden)'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.umap(adata, color=</span><span class="s3">'sample'</span><span class="s1">, title=</span><span class="s3">'UMAP by Sample'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### tSNE <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">sc.tl.tsne(adata)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.tsne(adata, color=</span><span class="s3">'leiden'</span><span class="s1">, title=</span><span class="s3">'tSNE Clusters (Leiden)'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.tsne(adata, color=</span><span class="s3">'sample'</span><span class="s1">, title=</span><span class="s3">'tSNE by Sample'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### How many cells come from each sample individually? How many total cells present in the entire dataset? <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">adata.obs[</span><span class="s3">'sample'</span><span class="s1">].value_counts()</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### How many clusters are present? 
29 (0 - 28) 
 
### What clustering resolution did you use? 
0.5 
 
### Use the second plot you created and briefly remark on whether you will perform integration. 
UMAP showed mixed data points across the clusters, except one sample, but for tSNE, the samples have more of less different sub-clusters in bigger clusters, which are mixed up. Integration might be necessary to remove batch effects completely. <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Integration (using harmonypy) <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">adata.obs</span><hr class="ls0"><span class="s0">#%% 
# Visualizing batch effect</span>
<span class="s1">%time</span>

<span class="s0"># Run Harmony</span>
<span class="s1">ho = hm.run_harmony(adata.obsm[</span><span class="s3">'X_pca'</span><span class="s1">], adata.obs, </span><span class="s3">'sample'</span><span class="s1">)</span>

<span class="s0"># Replace PCA with Harmony-corrected data</span>
<span class="s1">adata.obsm[</span><span class="s3">'X_pca_harmony'</span><span class="s1">] = ho.Z_corr.T</span>

<span class="s0"># Use Harmony PCA for UMAP and neighbors</span>
<span class="s1">adata.obsm[</span><span class="s3">'X_pca'</span><span class="s1">] = adata.obsm[</span><span class="s3">'X_pca_harmony'</span><span class="s1">]</span>
<span class="s1">sc.pp.neighbors(adata, use_rep=</span><span class="s3">'X_pca'</span><span class="s1">)</span>
<span class="s1">sc.tl.umap(adata)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.tl.leiden(adata, resolution=</span><span class="s4">0.6</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# plot</span>
<span class="s1">sc.pl.umap(adata, color=[</span><span class="s3">'sample'</span><span class="s1">,</span><span class="s3">'leiden'</span><span class="s1">])</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">## Find Marker genes <hr class="ls0"></span><span class="s0">#%% 
# Find marker genes</span>
<span class="s1">sc.tl.rank_genes_groups(adata, </span><span class="s3">'leiden'</span><span class="s1">, metric=</span><span class="s3">'logreg'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# Plot the top 5 genes</span>
<span class="s1">sc.pl.rank_genes_groups(adata, n_genes=</span><span class="s4">5</span><span class="s1">,sharey=</span><span class="s2">False</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">markers = sc.get.rank_genes_groups_df(adata, </span><span class="s2">None</span><span class="s1">)</span>
<span class="s1">markers = markers[(markers[</span><span class="s3">'pvals_adj'</span><span class="s1">] &lt; </span><span class="s4">0.05</span><span class="s1">) &amp; (markers[</span><span class="s3">'logfoldchanges'</span><span class="s1">] &gt; </span><span class="s4">0.5</span><span class="s1">)]</span>
<span class="s1">markers</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">Advantages: 
Suitable for multiple groups: Logistic regression is well-suited for analyzing data with more than two groups. 
Can handle complex relationships: It can model more complex relationships between genes and groups. 
 
Disadvantages: 
More complex to interpret: The results of logistic regression can be more complex to interpret than those of the t-test or Wilcoxon test. 
Requires more data: Logistic regression generally requires larger sample sizes than the t-test or Wilcoxon test <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Automated Annotation <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">The method used for this is celltypist. CellTypist uses logistic regression-based classification models trained on curated reference datasets covering a broad range of immune and non-immune cell types. It has multiple model types specific to each condition or organ or cell types. 
For annotation, we used the Immune_All_Low.pkl model, suitable for a broad range of immune cell types, particularly relevant given the tumor microenvironment focus of the dataset. 
 
Advantages: 
Fast and scalable for large datasets. 
Reproducible and standardized. 
Broad reference database coverage. 
 
Limitations: 
Accuracy is constrained by the reference model. 
May miss rare or novel cell types not represented in training data. 
Requires normalized, log-transformed expression input. 
 
Domínguez Conde, C., et al. (2022). Cross-tissue immune cell analysis reveals tissue-specific features in humans. Science, 376(6594), eabl5197. 
https://doi.org/10.1126/science.abl5197 <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">adata_celltypist.layers[</span><span class="s3">&quot;n_counts&quot;</span><span class="s1">] = adata_celltypist.X.copy()</span>
<span class="s1">adata_celltypist.obs_names_make_unique()</span>
<span class="s1">adata_celltypist.var_names_make_unique()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata_celltypist.obs</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">models.models_description()</span><hr class="ls0"><span class="s0">#%% 
# Step 1: Normalize to 10,000 counts per cell</span>
<span class="s1">sc.pp.normalize_total(adata_celltypist, target_sum=</span><span class="s4">1e4</span><span class="s1">)</span>

<span class="s0"># Step 2: Log1p transform</span>
<span class="s1">sc.pp.log1p(adata_celltypist)</span><hr class="ls0"><span class="s0">#%% 
# Check type</span>
<span class="s1">adata_celltypist</span><hr class="ls0"><span class="s0">#%% 
# Add the labels to all genes</span>
<span class="s1">predictions = celltypist.annotate(adata_celltypist, model = </span><span class="s3">'Immune_All_Low.pkl'</span><span class="s1">, majority_voting = </span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">predictions</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">predictions.predicted_labels</span><hr class="ls0"><span class="s0">#%% 
# Add predictions to your object (UNCOMMENT WHEN RUNNING FOR THE FIRST TIME)</span>
<span class="s1">adata_celltypist.obs = adata_celltypist.obs.join(predictions.predicted_labels)</span>

<span class="s0"># Prepare to visualize with UMAP</span>
<span class="s1">sc.pp.neighbors(adata_celltypist)</span>
<span class="s1">sc.tl.umap(adata_celltypist)</span>
<span class="s1">sc.tl.leiden(adata_celltypist, resolution=</span><span class="s4">0.6</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata_celltypist.obs</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.umap(adata_celltypist, color=[</span><span class="s3">'leiden'</span><span class="s1">])</span>
<span class="s1">sc.pl.umap(adata_celltypist, color=[</span><span class="s3">'predicted_labels'</span><span class="s1">])</span>
<span class="s1">sc.pl.umap(adata_celltypist, color=[</span><span class="s3">'majority_voting'</span><span class="s1">], legend_loc=</span><span class="s3">'on data'</span><span class="s1">)</span>
<span class="s1">sc.pl.umap(adata_celltypist, color=[</span><span class="s3">'majority_voting'</span><span class="s1">])</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">predominantly epithelial, fibroblasts. 
NK cells <hr class="ls0"></span><span class="s0">#%% 
</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">## Manual Annotation <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">markers</span><hr class="ls0"><span class="s0">#%% 
# For NK cells</span>
<span class="s1">sc.pl.umap(adata, color=</span><span class="s3">'NKG7'</span><span class="s1">, legend_loc=</span><span class="s3">'on data'</span><span class="s1">)</span>

<span class="s0"># For B cells</span>
<span class="s1">sc.pl.umap(adata, color=</span><span class="s3">'CD79A'</span><span class="s1">, legend_loc=</span><span class="s3">'on data'</span><span class="s1">)</span>

<span class="s0"># For T cells</span>
<span class="s1">sc.pl.umap(adata, color=</span><span class="s3">'CD3D'</span><span class="s1">, legend_loc=</span><span class="s3">'on data'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.umap(adata, color=[</span><span class="s3">'leiden'</span><span class="s1">], frameon=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">sc.pl.umap(adata, color=[</span><span class="s3">'leiden'</span><span class="s1">], legend_loc=</span><span class="s3">'on data'</span><span class="s1">, frameon=</span><span class="s2">False</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.umap(adata, color=</span><span class="s3">'MMP7'</span><span class="s1">, legend_loc=</span><span class="s3">'on data'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">Many cell markers and umap trials later... <hr class="ls0"></span><span class="s0">#%% 
# Define a dictionary to manually annotate the proteins and use it to add cluster labels</span>
<span class="s1">annotate = {}</span>
<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s1">,</span><span class="s4">29</span><span class="s1">):</span>
    <span class="s1">annotate[</span><span class="s3">f'</span><span class="s5">{</span><span class="s1">i</span><span class="s5">}</span><span class="s3">'</span><span class="s1">] = </span><span class="s3">&quot;&quot;</span>

<span class="s1">annotate</span><hr class="ls0"><span class="s0">#%% 
# Gene names for annotation taken from the original publication (https://www.nature.com/articles/s41467-023-40727-7/figures/1)</span>
<span class="s1">annotate = {</span><span class="s3">'0'</span><span class="s1">: </span><span class="s3">'Ductal Cells'</span><span class="s1">,</span>
 <span class="s3">'1'</span><span class="s1">: </span><span class="s3">'T cells'</span><span class="s1">,</span>
 <span class="s3">'2'</span><span class="s1">: </span><span class="s3">'Macrophages/Monocytes'</span><span class="s1">,</span>
 <span class="s3">'3'</span><span class="s1">: </span><span class="s3">'Acinar cells'</span><span class="s1">,</span>
 <span class="s3">'4'</span><span class="s1">: </span><span class="s3">'Ductal Cells'</span><span class="s1">,</span>
 <span class="s3">'5'</span><span class="s1">: </span><span class="s3">'Fibroblasts'</span><span class="s1">,</span>
 <span class="s3">'6'</span><span class="s1">: </span><span class="s3">'T cells'</span><span class="s1">,</span>
 <span class="s3">'7'</span><span class="s1">: </span><span class="s3">'Acinar cells'</span><span class="s1">,</span>
 <span class="s3">'8'</span><span class="s1">: </span><span class="s3">'NK cells'</span><span class="s1">,</span>
 <span class="s3">'9'</span><span class="s1">: </span><span class="s3">'T cells'</span><span class="s1">,</span>
 <span class="s3">'10'</span><span class="s1">: </span><span class="s3">'Macrophages/Monocytes'</span><span class="s1">,</span>
 <span class="s3">'11'</span><span class="s1">: </span><span class="s3">'Plasma Cells'</span><span class="s1">,</span>
 <span class="s3">'12'</span><span class="s1">: </span><span class="s3">'Macrophages/Monocytes'</span><span class="s1">,</span>
 <span class="s3">'13'</span><span class="s1">: </span><span class="s3">'MK167+ cell'</span><span class="s1">,</span>
 <span class="s3">'14'</span><span class="s1">: </span><span class="s3">'Macrophages/Monocytes'</span><span class="s1">,</span>
 <span class="s3">'15'</span><span class="s1">: </span><span class="s3">'Mast cells'</span><span class="s1">,</span>
 <span class="s3">'16'</span><span class="s1">: </span><span class="s3">'Ductal Cells'</span><span class="s1">,</span>
 <span class="s3">'17'</span><span class="s1">: </span><span class="s3">'MK167+ cell'</span><span class="s1">,</span>
 <span class="s3">'18'</span><span class="s1">: </span><span class="s3">'Endothelial cells'</span><span class="s1">,</span>
 <span class="s3">'19'</span><span class="s1">: </span><span class="s3">'B cells'</span><span class="s1">,</span>
 <span class="s3">'20'</span><span class="s1">: </span><span class="s3">'Plasma cells'</span><span class="s1">,</span>
 <span class="s3">'21'</span><span class="s1">: </span><span class="s3">'Plasma cells'</span><span class="s1">,</span>
 <span class="s3">'22'</span><span class="s1">: </span><span class="s3">'Ductal Cells'</span><span class="s1">,</span>
 <span class="s3">'23'</span><span class="s1">: </span><span class="s3">'Ductal Cells'</span><span class="s1">,</span>
 <span class="s3">'24'</span><span class="s1">: </span><span class="s3">'Macrophages/Monocytes'</span><span class="s1">,</span>
 <span class="s3">'25'</span><span class="s1">: </span><span class="s3">'Uncertain'</span><span class="s1">,</span>
 <span class="s3">'26'</span><span class="s1">: </span><span class="s3">'T cells'</span><span class="s1">,</span>
 <span class="s3">'27'</span><span class="s1">: </span><span class="s3">'Endothelial cells'</span><span class="s1">,</span>
 <span class="s3">'28'</span><span class="s1">: </span><span class="s3">'Endothelial cells'</span><span class="s1">}</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata.obs</span><hr class="ls0"><span class="s0">#%% 
# Assign cell type to each cluster</span>
<span class="s1">adata.obs[</span><span class="s3">'celltype'</span><span class="s1">] = adata.obs[</span><span class="s3">'leiden'</span><span class="s1">].map(annotate)</span><hr class="ls0"><span class="s0">#%% 
# Visualize UMAP with cell types</span>
<span class="s1">sc.pl.umap(adata, color=</span><span class="s3">'celltype'</span><span class="s1">, title=</span><span class="s3">'Cell Type Annotation'</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% 
# Plot top 5 genes from each cluster as a heatmap and dot plot</span>
<span class="s1">sc.pl.rank_genes_groups_heatmap(adata, n_genes=</span><span class="s4">5</span><span class="s1">, groupby=</span><span class="s3">'leiden'</span><span class="s1">, show=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">sc.pl.rank_genes_groups_dotplot(adata, n_genes=</span><span class="s4">5</span><span class="s1">, groupby=</span><span class="s3">'leiden'</span><span class="s1">, show=</span><span class="s2">True</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% 
# Find top 3 populous clusters</span>
<span class="s1">top_clusters = adata.obs[</span><span class="s3">'leiden'</span><span class="s1">].value_counts().head(</span><span class="s4">3</span><span class="s1">).index.tolist()</span>
<span class="s1">print(</span><span class="s3">&quot;Top clusters:&quot;</span><span class="s1">, top_clusters)</span>

<span class="s1">sc.tl.rank_genes_groups(adata, </span><span class="s3">'leiden'</span><span class="s1">, method=</span><span class="s3">'t-test'</span><span class="s1">)  </span><span class="s0"># if not already done</span>
<span class="s1">top_markers = {}</span>
<span class="s2">for </span><span class="s1">cluster </span><span class="s2">in </span><span class="s1">top_clusters:</span>
    <span class="s1">top = adata.uns[</span><span class="s3">'rank_genes_groups'</span><span class="s1">][</span><span class="s3">'names'</span><span class="s1">][cluster][:</span><span class="s4">5</span><span class="s1">]</span>
    <span class="s1">top_markers[cluster] = top</span>
<hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata.obs.columns</span><hr class="ls0"><span class="s0">#%% 
# Get top marker genes for cluster '0'</span>
<span class="s1">top_clusters = [</span><span class="s3">'0'</span><span class="s1">, </span><span class="s3">'1'</span><span class="s1">, </span><span class="s3">'2'</span><span class="s1">]</span>
<span class="s2">for </span><span class="s1">cluster </span><span class="s2">in </span><span class="s1">top_clusters:</span>
    <span class="s1">print(</span><span class="s3">'Top 5 genes from cluster'</span><span class="s1">, cluster)</span>
    <span class="s1">genes = adata.uns[</span><span class="s3">'rank_genes_groups'</span><span class="s1">][</span><span class="s3">'names'</span><span class="s1">][cluster][:</span><span class="s4">5</span><span class="s1">]</span>
    <span class="s1">sc.pl.dotplot(adata, var_names=genes, groupby=</span><span class="s3">'leiden'</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% 
</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">Each cluster is annotated by referring to the original article. They had a heatmap with marker genes and associated cell types. I used that as my reference list. 
 
Marker genes : https://www.nature.com/articles/s41467-023-40727-7#Fig1 
 
Method to manually annotate: inclass and this cool YT video https://www.youtube.com/watch?v=uvyG9yLuNSE&amp;t=2874s <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Pseudotime Analysis (PAGA and dpt) <hr class="ls0"></span><span class="s0">#%% 
# select Ductal cells</span>
<span class="s1">subset = adata[adata.obs[</span><span class="s3">'celltype'</span><span class="s1">] == </span><span class="s3">'Ductal Cells'</span><span class="s1">].copy()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">subset</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">print(subset.shape)</span>
<span class="s1">print(</span><span class="s3">&quot;Subclusters in Ductal cells: </span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">,subset.obs[</span><span class="s3">'leiden'</span><span class="s1">].unique())</span>
<span class="s1">print(subset.obs[</span><span class="s3">'leiden'</span><span class="s1">].value_counts())</span><hr class="ls0"><span class="s0">#%% 
# Preprocess and prepare data </span>
<span class="s1">sc.pp.highly_variable_genes(subset, n_top_genes=</span><span class="s4">2000</span><span class="s1">)</span>
<span class="s1">subset = subset[:, subset.var.highly_variable]</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pp.scale(subset, max_value=</span><span class="s4">10</span><span class="s1">)</span>
<span class="s1">sc.tl.pca(subset, svd_solver=</span><span class="s3">'arpack'</span><span class="s1">)</span>
<span class="s1">sc.tl.umap(subset)</span><hr class="ls0"><span class="s0">#%% 
# Recompute neighbors using same parameters</span>
<span class="s1">sc.pp.neighbors(subset, n_neighbors=</span><span class="s4">10</span><span class="s1">, n_pcs=</span><span class="s4">30</span><span class="s1">)</span>

<span class="s0"># Run PAGA</span>
<span class="s1">sc.tl.paga(subset, groups=</span><span class="s3">'leiden'</span><span class="s1">)</span>
<span class="s1">sc.pl.paga(subset, plot=</span><span class="s2">True</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% 
# Use PAGA positions to initialize UMAP</span>
<span class="s1">sc.tl.umap(subset, init_pos=</span><span class="s3">'paga'</span><span class="s1">)</span>

<span class="s0"># Plot UMAP with PAGA overlay</span>
<span class="s1">sc.pl.umap(subset, color=[</span><span class="s3">'leiden'</span><span class="s1">], edges=</span><span class="s2">True</span><span class="s1">, title=</span><span class="s3">'UMAP with PAGA Overlay'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### Figures from publication (Figure 3c) <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">sc.tl.diffmap(subset)</span>
<hr class="ls0"><span class="s0">#%% 
</span><span class="s1">root_ixs = subset.obsm[</span><span class="s3">'X_diffmap'</span><span class="s1">][:, </span><span class="s4">3</span><span class="s1">].argmax()</span>
<span class="s1">subset.obsm[</span><span class="s3">'X_diffmap'</span><span class="s1">][:, </span><span class="s4">3</span><span class="s1">].argmax()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">scv.pl.scatter(</span>
    <span class="s1">subset,</span>
    <span class="s1">basis=</span><span class="s3">&quot;diffmap&quot;</span><span class="s1">,</span>
    <span class="s1">c=[</span><span class="s3">&quot;leiden&quot;</span><span class="s1">, root_ixs],</span>
    <span class="s1">legend_loc=</span><span class="s3">&quot;right&quot;</span><span class="s1">,</span>
    <span class="s1">components=[</span><span class="s3">&quot;2, 3&quot;</span><span class="s1">],</span>
<span class="s1">)</span>

<span class="s1">subset.uns[</span><span class="s3">&quot;iroot&quot;</span><span class="s1">] = root_ixs</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.tl.dpt(subset)</span><hr class="ls0"><span class="s0">#%% 
# Prepare data for sample_groups visualization</span>
<span class="s1">subset.obs[</span><span class="s3">'sample'</span><span class="s1">].unique()</span>
<span class="s2">def </span><span class="s1">map_sample_to_group(sample_name):</span>
    <span class="s2">if </span><span class="s3">'_zc' </span><span class="s2">in </span><span class="s1">sample_name:</span>
        <span class="s2">return </span><span class="s3">'NT'</span>
    <span class="s2">elif </span><span class="s3">'_yf' </span><span class="s2">in </span><span class="s1">sample_name:</span>
        <span class="s2">return </span><span class="s3">'PT'</span>
    <span class="s2">elif </span><span class="s3">'_zy' </span><span class="s2">in </span><span class="s1">sample_name:</span>
        <span class="s2">return </span><span class="s3">'HM'</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">'Unknown'</span>

<span class="s1">subset.obs[</span><span class="s3">'sample_group'</span><span class="s1">] = subset.obs[</span><span class="s3">'sample'</span><span class="s1">].apply(map_sample_to_group)</span>

<span class="s1">subset.obs[</span><span class="s3">'sample_group'</span><span class="s1">].value_counts()</span><hr class="ls0"><span class="s0">#%% 
# Define cell states using Pandas</span>
<span class="s1">subset.obs[</span><span class="s3">'cell_state'</span><span class="s1">] = pd.qcut(subset.obs[</span><span class="s3">'dpt_pseudotime'</span><span class="s1">], q=</span><span class="s4">5</span><span class="s1">, labels=[</span><span class="s3">'S1'</span><span class="s1">, </span><span class="s3">'S2'</span><span class="s1">, </span><span class="s3">'S3'</span><span class="s1">, </span><span class="s3">'S4'</span><span class="s1">, </span><span class="s3">'S5'</span><span class="s1">])</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">subset.var_names</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">sc.pl.umap(subset, color=[</span><span class="s3">'dpt_pseudotime'</span><span class="s1">,</span><span class="s3">'leiden'</span><span class="s1">], color_map=</span><span class="s3">'plasma'</span><span class="s1">, frameon=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">sc.pl.umap(subset,color=</span><span class="s3">'sample_group'</span><span class="s1">,color_map=</span><span class="s3">'plasma'</span><span class="s1">, frameon=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">sc.pl.umap(subset, color=</span><span class="s3">'cell_state'</span><span class="s1">, color_map=</span><span class="s3">'plasma'</span><span class="s1">, frameon=</span><span class="s2">False</span><span class="s1">)</span>
<span class="s1">sc.pl.umap(subset, color=</span><span class="s3">'AAK1'</span><span class="s1">, color_map=</span><span class="s3">'Reds'</span><span class="s1">, frameon=</span><span class="s2">False</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">In the orignal article, authors used monocle2, but here, PAGA and dpt are used. from the above figures, NT cells were confined to S2 cell_state. NT cells are completely differentiable in the above UMAP. S5 has all the NT cells, but it also includes other cells. 
Zhang, S., Fang, W., Zhou, S. et al. Single cell transcriptomic analyses implicate an immunosuppressive tumor microenvironment in pancreatic cancer liver metastasis. Nat Commun 14, 5123 (2023). https://doi.org/10.1038/s41467-023-40727-7 <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Cell-Cell Interaction analysis (CellPhoneDB) <hr class="ls0"></span><span class="s0">#%% 
# Installing cellphonedb using instructions from (https://github.com/ventolab/CellphoneDB/blob/master/notebooks/T0_DownloadDB.ipynb)</span>
<span class="s2">from </span><span class="s1">IPython.display </span><span class="s2">import </span><span class="s1">HTML, display</span>
<span class="s2">from </span><span class="s1">cellphonedb.utils </span><span class="s2">import </span><span class="s1">db_releases_utils</span>
<span class="s2">from </span><span class="s1">cellphonedb.utils </span><span class="s2">import </span><span class="s1">db_utils</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s1">display(HTML(db_releases_utils.get_remote_database_versions_html()[</span><span class="s3">'db_releases_html_table'</span><span class="s1">]))</span>

<span class="s0"># -- Version of the database</span>
<span class="s1">cpdb_version = </span><span class="s3">'v5.0.0'</span>

<span class="s0"># -- Path where the input files to generate the database are located</span>
<span class="s1">cpdb_target_dir = os.path.join(</span><span class="s3">''</span><span class="s1">, cpdb_version)</span>

<span class="s1">db_utils.download_database(cpdb_target_dir, cpdb_version)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata</span><hr class="ls0"><span class="s0">#%% 
# prepare data</span>
<span class="s1">adata.var_names_make_unique()</span>
<hr class="ls0"><span class="s0">#%% 
# Cell metadata file</span>
<span class="s1">meta = adata.obs[[</span><span class="s3">'celltype'</span><span class="s1">]].copy()</span>
<span class="s1">meta.reset_index(inplace=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">meta.columns = [</span><span class="s3">'Cell'</span><span class="s1">, </span><span class="s3">'celltype'</span><span class="s1">]</span>
<span class="s1">meta.to_csv(</span><span class="s3">&quot;cellphone_meta.txt&quot;</span><span class="s1">, sep=</span><span class="s3">&quot;</span><span class="s5">\t</span><span class="s3">&quot;</span><span class="s1">, index=</span><span class="s2">False</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# Expression matrix (genes x cells)</span>
<span class="s0"># TAKES 7-10 MINUTES</span>

<span class="s0">#expr = adata.to_df().T</span>
<span class="s0">#expr.to_csv(&quot;cellphone_counts.txt&quot;, sep=&quot;\t&quot;)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">meta.head()</span><hr class="ls0"><span class="s0">#%% 
# DO NOT RUN AGAIN UNLESS expr CHANGED</span>
<span class="s0"># expr.head()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">cpdb_results = cpdb_analysis_method.call(</span>
        <span class="s1">cpdb_file_path = </span><span class="s3">'v5.0.0/cellphonedb.zip'</span><span class="s1">,</span>
        <span class="s1">meta_file_path = </span><span class="s3">'cellphone_meta.txt'</span><span class="s1">,</span>
        <span class="s1">counts_file_path = </span><span class="s3">'cellphone_counts.txt'</span><span class="s1">,</span>
        <span class="s1">counts_data = </span><span class="s3">'hgnc_symbol'</span><span class="s1">,</span>
        <span class="s1">score_interactions = </span><span class="s2">True</span><span class="s1">,</span>
        <span class="s1">output_path = </span><span class="s3">'cellphonedb/'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">cpdb_results</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">### For replicating the figure 7a from the publication, we need to sort the samples according to the condition and them perform it individually <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">Sample codes according to https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE197177: 
1. ZC: normal pancreatic tissue 
2. YF: pancreatic tumors 
3. ZY: hepatic metastases <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">adata.obs[</span><span class="s3">'sample'</span><span class="s1">].unique()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata_PT = adata[adata.obs[</span><span class="s3">'sample'</span><span class="s1">].isin([</span><span class="s3">'case1_yf'</span><span class="s1">, </span><span class="s3">'case2_yf'</span><span class="s1">, </span><span class="s3">'case3_yf'</span><span class="s1">])]</span>
<span class="s1">adata_NT = adata[adata.obs[</span><span class="s3">'sample'</span><span class="s1">] == </span><span class="s3">'case2_zc'</span><span class="s1">]</span>
<span class="s1">adata_HM = adata[adata.obs[</span><span class="s3">'sample'</span><span class="s1">].isin([</span><span class="s3">'case1_zy'</span><span class="s1">, </span><span class="s3">'case2_zy'</span><span class="s1">, </span><span class="s3">'case3_zy'</span><span class="s1">, </span><span class="s3">'case4_zy'</span><span class="s1">])]</span>

<span class="s1">print(adata.shape)</span>
<span class="s1">print(adata_PT.shape)</span>
<span class="s1">print(adata_NT.shape)</span>
<span class="s1">print(adata_HM.shape)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">#### For PT cells <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">meta = adata_PT.obs[[</span><span class="s3">'celltype'</span><span class="s1">]].copy()</span>
<span class="s1">meta.reset_index(inplace=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">meta.columns = [</span><span class="s3">'Cell'</span><span class="s1">, </span><span class="s3">'celltype'</span><span class="s1">]</span>
<span class="s1">meta.to_csv(</span><span class="s3">&quot;pt_meta.txt&quot;</span><span class="s1">, sep=</span><span class="s3">&quot;</span><span class="s5">\t</span><span class="s3">&quot;</span><span class="s1">, index=</span><span class="s2">False</span><span class="s1">)</span>

<span class="s1">expr = adata_PT.to_df().T</span>
<span class="s1">expr.to_csv(</span><span class="s3">&quot;pt_counts.txt&quot;</span><span class="s1">, sep=</span><span class="s3">&quot;</span><span class="s5">\t</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s1">cpdb_results_pt = cpdb_analysis_method.call(</span>
        <span class="s1">cpdb_file_path = </span><span class="s3">'v5.0.0/cellphonedb.zip'</span><span class="s1">,</span>
        <span class="s1">meta_file_path = </span><span class="s3">'pt_meta.txt'</span><span class="s1">,</span>
        <span class="s1">counts_file_path = </span><span class="s3">'pt_counts.txt'</span><span class="s1">,</span>
        <span class="s1">counts_data = </span><span class="s3">'hgnc_symbol'</span><span class="s1">,</span>
        <span class="s1">score_interactions = </span><span class="s2">True</span><span class="s1">,</span>
        <span class="s1">output_path = </span><span class="s3">'cellphonedb/pt/'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# Heatmap visualization</span>
<span class="s1">means_pt = pd.read_csv(</span><span class="s3">'cellphonedb/pt/simple_analysis_means_result_05_07_2025_131112.txt'</span><span class="s1">, sep=</span><span class="s3">'</span><span class="s5">\t</span><span class="s3">'</span><span class="s1">)</span>

<span class="s0"># Select only the columns with cell-type interactions (skip first 2 columns: 'interacting_pair' and 'gene_a/gene_b')</span>
<span class="s1">interaction_cols = means_pt.columns[means_pt.columns.str.contains(</span><span class="s3">r'\|'</span><span class="s1">)]</span>

<span class="s0"># Compute the average interaction strength between each pair of cell types</span>
<span class="s1">interaction_means = means_pt[interaction_cols].mean(axis=</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0"># Convert to square matrix for heatmap</span>
<span class="s1">interaction_matrix = interaction_means.reset_index()</span>
<span class="s1">interaction_matrix.columns = [</span><span class="s3">'cell_pair'</span><span class="s1">, </span><span class="s3">'mean_score'</span><span class="s1">]</span>

<span class="s0"># Split sender|receiver into two columns</span>
<span class="s1">interaction_matrix[[</span><span class="s3">'source'</span><span class="s1">, </span><span class="s3">'target'</span><span class="s1">]] = interaction_matrix[</span><span class="s3">'cell_pair'</span><span class="s1">].str.split(</span><span class="s3">r'\|'</span><span class="s1">, expand=</span><span class="s2">True</span><span class="s1">)</span>

<span class="s0"># Pivot into matrix</span>
<span class="s1">heatmap_pt = interaction_matrix.pivot(index=</span><span class="s3">'source'</span><span class="s1">, columns=</span><span class="s3">'target'</span><span class="s1">, values=</span><span class="s3">'mean_score'</span><span class="s1">).fillna(</span><span class="s4">0</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">#### For NT cells <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">meta = adata_NT.obs[[</span><span class="s3">'celltype'</span><span class="s1">]].copy()</span>
<span class="s1">meta.reset_index(inplace=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">meta.columns = [</span><span class="s3">'Cell'</span><span class="s1">, </span><span class="s3">'celltype'</span><span class="s1">]</span>
<span class="s1">meta.to_csv(</span><span class="s3">&quot;nt_meta.txt&quot;</span><span class="s1">, sep=</span><span class="s3">&quot;</span><span class="s5">\t</span><span class="s3">&quot;</span><span class="s1">, index=</span><span class="s2">False</span><span class="s1">)</span>

<span class="s1">expr = adata_NT.to_df().T</span>
<span class="s1">expr.to_csv(</span><span class="s3">&quot;nt_counts.txt&quot;</span><span class="s1">, sep=</span><span class="s3">&quot;</span><span class="s5">\t</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s1">cpdb_results_nt = cpdb_analysis_method.call(</span>
        <span class="s1">cpdb_file_path = </span><span class="s3">'v5.0.0/cellphonedb.zip'</span><span class="s1">,</span>
        <span class="s1">meta_file_path = </span><span class="s3">'nt_meta.txt'</span><span class="s1">,</span>
        <span class="s1">counts_file_path = </span><span class="s3">'nt_counts.txt'</span><span class="s1">,</span>
        <span class="s1">counts_data = </span><span class="s3">'hgnc_symbol'</span><span class="s1">,</span>
        <span class="s1">score_interactions = </span><span class="s2">True</span><span class="s1">,</span>
        <span class="s1">output_path = </span><span class="s3">'cellphonedb/nt/'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# Heatmap visualization</span>
<span class="s1">means_nt = pd.read_csv(</span><span class="s3">'cellphonedb/nt/simple_analysis_means_result_05_07_2025_131135.txt'</span><span class="s1">, sep=</span><span class="s3">'</span><span class="s5">\t</span><span class="s3">'</span><span class="s1">)</span>

<span class="s0"># Select only the columns with cell-type interactions (skip first 2 columns: 'interacting_pair' and 'gene_a/gene_b')</span>
<span class="s1">interaction_cols = means_nt.columns[means_nt.columns.str.contains(</span><span class="s3">r'\|'</span><span class="s1">)]</span>

<span class="s0"># Compute the average interaction strength between each pair of cell types</span>
<span class="s1">interaction_means = means_nt[interaction_cols].mean(axis=</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0"># Convert to square matrix for heatmap</span>
<span class="s1">interaction_matrix = interaction_means.reset_index()</span>
<span class="s1">interaction_matrix.columns = [</span><span class="s3">'cell_pair'</span><span class="s1">, </span><span class="s3">'mean_score'</span><span class="s1">]</span>

<span class="s0"># Split sender|receiver into two columns</span>
<span class="s1">interaction_matrix[[</span><span class="s3">'source'</span><span class="s1">, </span><span class="s3">'target'</span><span class="s1">]] = interaction_matrix[</span><span class="s3">'cell_pair'</span><span class="s1">].str.split(</span><span class="s3">r'\|'</span><span class="s1">, expand=</span><span class="s2">True</span><span class="s1">)</span>

<span class="s0"># Pivot into matrix</span>
<span class="s1">heatmap_nt = interaction_matrix.pivot(index=</span><span class="s3">'source'</span><span class="s1">, columns=</span><span class="s3">'target'</span><span class="s1">, values=</span><span class="s3">'mean_score'</span><span class="s1">).fillna(</span><span class="s4">0</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">#### For HM Cells <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">meta = adata_HM.obs[[</span><span class="s3">'celltype'</span><span class="s1">]].copy()</span>
<span class="s1">meta.reset_index(inplace=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">meta.columns = [</span><span class="s3">'Cell'</span><span class="s1">, </span><span class="s3">'celltype'</span><span class="s1">]</span>
<span class="s1">meta.to_csv(</span><span class="s3">&quot;hm_meta.txt&quot;</span><span class="s1">, sep=</span><span class="s3">&quot;</span><span class="s5">\t</span><span class="s3">&quot;</span><span class="s1">, index=</span><span class="s2">False</span><span class="s1">)</span>

<span class="s1">expr = adata_HM.to_df().T</span>
<span class="s1">expr.to_csv(</span><span class="s3">&quot;hm_counts.txt&quot;</span><span class="s1">, sep=</span><span class="s3">&quot;</span><span class="s5">\t</span><span class="s3">&quot;</span><span class="s1">)</span>

<span class="s1">cpdb_results_hm = cpdb_analysis_method.call(</span>
        <span class="s1">cpdb_file_path = </span><span class="s3">'v5.0.0/cellphonedb.zip'</span><span class="s1">,</span>
        <span class="s1">meta_file_path = </span><span class="s3">'hm_meta.txt'</span><span class="s1">,</span>
        <span class="s1">counts_file_path = </span><span class="s3">'hm_counts.txt'</span><span class="s1">,</span>
        <span class="s1">counts_data = </span><span class="s3">'hgnc_symbol'</span><span class="s1">,</span>
        <span class="s1">output_path = </span><span class="s3">'cellphonedb/hm/'</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
# Heatmap visualization</span>
<span class="s1">means_hm = pd.read_csv(</span><span class="s3">'cellphonedb/hm/simple_analysis_means_result_05_07_2025_132311.txt'</span><span class="s1">, sep=</span><span class="s3">'</span><span class="s5">\t</span><span class="s3">'</span><span class="s1">)</span>

<span class="s0"># Select only the columns with cell-type interactions (skip first 2 columns: 'interacting_pair' and 'gene_a/gene_b')</span>
<span class="s1">interaction_cols = means_hm.columns[means_hm.columns.str.contains(</span><span class="s3">r'\|'</span><span class="s1">)]</span>

<span class="s0"># Compute the average interaction strength between each pair of cell types</span>
<span class="s1">interaction_means = means_hm[interaction_cols].mean(axis=</span><span class="s4">0</span><span class="s1">)</span>

<span class="s0"># Convert to square matrix for heatmap</span>
<span class="s1">interaction_matrix = interaction_means.reset_index()</span>
<span class="s1">interaction_matrix.columns = [</span><span class="s3">'cell_pair'</span><span class="s1">, </span><span class="s3">'mean_score'</span><span class="s1">]</span>

<span class="s0"># Split sender|receiver into two columns</span>
<span class="s1">interaction_matrix[[</span><span class="s3">'source'</span><span class="s1">, </span><span class="s3">'target'</span><span class="s1">]] = interaction_matrix[</span><span class="s3">'cell_pair'</span><span class="s1">].str.split(</span><span class="s3">r'\|'</span><span class="s1">, expand=</span><span class="s2">True</span><span class="s1">)</span>

<span class="s0"># Pivot into matrix</span>
<span class="s1">heatmap_hm = interaction_matrix.pivot(index=</span><span class="s3">'source'</span><span class="s1">, columns=</span><span class="s3">'target'</span><span class="s1">, values=</span><span class="s3">'mean_score'</span><span class="s1">).fillna(</span><span class="s4">0</span><span class="s1">)</span>
<hr class="ls0"><span class="s0">#%% 
</span><span class="s1">fig, axs = plt.subplots(</span><span class="s4">1</span><span class="s1">, </span><span class="s4">3</span><span class="s1">, figsize=(</span><span class="s4">24</span><span class="s1">, </span><span class="s4">8</span><span class="s1">))  </span><span class="s0"># 1 row, 3 columns</span>

<span class="s0"># PT heatmap</span>
<span class="s1">sns.heatmap(heatmap_pt, cmap=</span><span class="s3">'Reds'</span><span class="s1">, linewidths=</span><span class="s4">0.5</span><span class="s1">, annot=</span><span class="s2">True</span><span class="s1">, fmt=</span><span class="s3">&quot;.2f&quot;</span><span class="s1">, ax=axs[</span><span class="s4">0</span><span class="s1">])</span>
<span class="s1">axs[</span><span class="s4">0</span><span class="s1">].set_title(</span><span class="s3">'Cell–Cell Interaction in PT'</span><span class="s1">)</span>
<span class="s1">axs[</span><span class="s4">0</span><span class="s1">].set_xlabel(</span><span class="s3">'Target Cell Type'</span><span class="s1">)</span>
<span class="s1">axs[</span><span class="s4">0</span><span class="s1">].set_ylabel(</span><span class="s3">'Source Cell Type'</span><span class="s1">)</span>

<span class="s0"># NT heatmap</span>
<span class="s1">sns.heatmap(heatmap_nt, cmap=</span><span class="s3">'Reds'</span><span class="s1">, linewidths=</span><span class="s4">0.5</span><span class="s1">, annot=</span><span class="s2">True</span><span class="s1">, fmt=</span><span class="s3">&quot;.2f&quot;</span><span class="s1">, ax=axs[</span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">axs[</span><span class="s4">1</span><span class="s1">].set_title(</span><span class="s3">'Cell–Cell Interaction in NT'</span><span class="s1">)</span>
<span class="s1">axs[</span><span class="s4">1</span><span class="s1">].set_xlabel(</span><span class="s3">'Target Cell Type'</span><span class="s1">)</span>
<span class="s1">axs[</span><span class="s4">1</span><span class="s1">].set_ylabel(</span><span class="s3">''</span><span class="s1">)</span>

<span class="s0"># HM heatmap</span>
<span class="s1">sns.heatmap(heatmap_hm, cmap=</span><span class="s3">'Reds'</span><span class="s1">, linewidths=</span><span class="s4">0.5</span><span class="s1">, annot=</span><span class="s2">True</span><span class="s1">, fmt=</span><span class="s3">&quot;.2f&quot;</span><span class="s1">, ax=axs[</span><span class="s4">2</span><span class="s1">])</span>
<span class="s1">axs[</span><span class="s4">2</span><span class="s1">].set_title(</span><span class="s3">'Cell–Cell Interaction in HM'</span><span class="s1">)</span>
<span class="s1">axs[</span><span class="s4">2</span><span class="s1">].set_xlabel(</span><span class="s3">'Target Cell Type'</span><span class="s1">)</span>
<span class="s1">axs[</span><span class="s4">2</span><span class="s1">].set_ylabel(</span><span class="s3">''</span><span class="s1">)</span>

<span class="s1">plt.tight_layout()</span>
<span class="s1">plt.show()</span>
<hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">From the above heatmaps, the cell-cell interaction differs from sample to sample. It is the highest for NT (normal pancreatic cells). Macrophages/Monocytes also maintain moderate interaction levels with multiple cell types, including Fibroblasts and MKI67+ cells, reinforcing their potential role in tissue remodeling and repair in normal tissue contexts (Wynn TA, 2016). 
In pancreatic tumour cells, the fibroblasts show the most interaction, especially with macrophages/monocytes. In the pancreatic tumor microenvironment, cancer-associated fibroblasts (CAFs) play a crucial role in interacting with tumor-associated macrophages (TAMs) (Gunaydin G. 2021). CAFs as well as TAMs are known to play pivotal supportive roles in tumor growth and progression. 
For the third sample type, hepatic metastacised cells, these interactions can be either protective, promoting anti-tumor immunity, or detrimental, facilitating metastasis. CD4+ T cells can help license dendritic cells (DCs) to better present antigens to CD8+ T cells, enhancing anti-tumor CD8+ T cell responses. However, they can also contribute to immunosuppression, producing IL-22 that promotes angiogenesis and metastasis, or becoming regulatory T cells (Tregs) that suppress anti-tumor immunity (Wu K. 2024). 
 
1. Wynn TA, Vannella KM. Macrophages in Tissue Repair, Regeneration, and Fibrosis. Immunity. 2016 Mar 15;44(3):450-462. doi: 10.1016/j.immuni.2016.02.015. PMID: 26982353; PMCID: PMC4794754. 
2. Gunaydin G. CAFs Interacting With TAMs in Tumor Microenvironment to Enhance Tumorigenesis and Immune Evasion. Front Oncol. 2021 Jul 14;11:668349. doi: 10.3389/fonc.2021.668349. PMID: 34336660; PMCID: PMC8317617. 
3. Wu, K., Zhang, G., Shen, C. et al. Role of T cells in liver metastasis. Cell Death Dis 15, 341 (2024). https://doi.org/10.1038/s41419-024-06726-2 <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Cell Proportion Analysis (scCODA) <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">adata.obs[</span><span class="s3">'sample'</span><span class="s1">].unique()</span>

<span class="s1">adata.obs[</span><span class="s3">'sample_group'</span><span class="s1">] = adata.obs[</span><span class="s3">'sample'</span><span class="s1">].apply(map_sample_to_group)</span>

<span class="s1">adata.obs[</span><span class="s3">'sample_group'</span><span class="s1">].value_counts()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata.obs</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">ct_counts = adata.obs.groupby([</span><span class="s3">&quot;sample_group&quot;</span><span class="s1">, </span><span class="s3">&quot;celltype&quot;</span><span class="s1">]).size().unstack(fill_value=</span><span class="s4">0</span><span class="s1">)</span>
<span class="s1">ct_props = ct_counts.div(ct_counts.sum(axis=</span><span class="s4">1</span><span class="s1">), axis=</span><span class="s4">0</span><span class="s1">)</span>

<span class="s1">ct_props.plot(kind=</span><span class="s3">&quot;bar&quot;</span><span class="s1">, stacked=</span><span class="s2">True</span><span class="s1">, figsize=(</span><span class="s4">12</span><span class="s1">,</span><span class="s4">6</span><span class="s1">))</span>
<span class="s1">plt.ylabel(</span><span class="s3">&quot;Cell type proportion&quot;</span><span class="s1">)</span>
<span class="s1">plt.title(</span><span class="s3">&quot;Composition per sample group&quot;</span><span class="s1">)</span>
<span class="s1">plt.show()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">cov_df = adata.obs.groupby(</span><span class="s3">&quot;sample&quot;</span><span class="s1">).first()[[</span><span class="s3">&quot;sample_group&quot;</span><span class="s1">]]</span>
<span class="s1">print(cov_df)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">data_sccoda = dat.from_scanpy(</span>
    <span class="s1">adata,</span>
    <span class="s1">cell_type_identifier=</span><span class="s3">&quot;celltype&quot;</span><span class="s1">,</span>
    <span class="s1">sample_identifier=</span><span class="s3">&quot;sample&quot;</span><span class="s1">,</span>
    <span class="s1">covariate_df=cov_df</span>
<span class="s1">)</span>
<span class="s1">data_sccoda</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">model = mod.CompositionalAnalysis(data_sccoda, formula=</span><span class="s3">&quot;sample_group&quot;</span><span class="s1">)</span>
<span class="s1">results = model.sample_hmc()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">results_df = results.summary()</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">No substantial result was found for manual annotation, so trying out automatic annotation labels <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">adata = ad.concat(adatas, join=</span><span class="s3">'outer'</span><span class="s1">, label=</span><span class="s3">'sample'</span><span class="s1">)</span>
<span class="s1">adata.obs_names_make_unique()</span><hr class="ls0"><span class="s0">#%% 
# Step 1: Normalize to 10,000 counts per cell</span>
<span class="s1">sc.pp.normalize_total(adata, target_sum=</span><span class="s4">1e4</span><span class="s1">)</span>

<span class="s0"># Step 2: Log1p transform</span>
<span class="s1">sc.pp.log1p(adata)</span><hr class="ls0"><span class="s0">#%% 
# Add the labels to all genes</span>
<span class="s1">predictions = celltypist.annotate(adata, model = </span><span class="s3">'Immune_All_Low.pkl'</span><span class="s1">, majority_voting = </span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">predictions</span><hr class="ls0"><span class="s0">#%% 
# Add predictions to your object (UNCOMMENT WHEN RUNNING FOR THE FIRST TIME)</span>
<span class="s1">adata.obs = adata.obs.join(predictions.predicted_labels)</span>

<span class="s0"># Prepare to visualize with UMAP</span>
<span class="s1">sc.pp.neighbors(adata)</span>
<span class="s1">sc.tl.umap(adata)</span>
<span class="s1">sc.tl.leiden(adata, resolution=</span><span class="s4">0.6</span><span class="s1">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata.obs[</span><span class="s3">'sample'</span><span class="s1">].unique()</span>

<span class="s1">adata.obs[</span><span class="s3">'sample_group'</span><span class="s1">] = adata.obs[</span><span class="s3">'sample'</span><span class="s1">].apply(map_sample_to_group)</span>

<span class="s1">adata.obs[</span><span class="s3">'sample_group'</span><span class="s1">].value_counts()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">adata.obs.head()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">cov_df = adata.obs.groupby(</span><span class="s3">&quot;sample&quot;</span><span class="s1">).first()[[</span><span class="s3">&quot;sample_group&quot;</span><span class="s1">]]</span>
<span class="s1">print(cov_df)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">data_sccoda = dat.from_scanpy(</span>
    <span class="s1">adata,</span>
    <span class="s1">cell_type_identifier=</span><span class="s3">&quot;majority_voting&quot;</span><span class="s1">,</span>
    <span class="s1">sample_identifier=</span><span class="s3">&quot;sample&quot;</span><span class="s1">,</span>
    <span class="s1">covariate_df=cov_df</span>
<span class="s1">)</span>
<span class="s1">data_sccoda</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">model = mod.CompositionalAnalysis(data_sccoda, formula=</span><span class="s3">&quot;sample_group&quot;</span><span class="s1">)</span>
<span class="s1">results = model.sample_hmc()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">results.summary()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">results.summary_extended()</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s1">az.plot_trace(</span>
    <span class="s1">results,</span>
    <span class="s1">divergences=</span><span class="s2">False</span><span class="s1">,</span>
    <span class="s1">var_names=[</span><span class="s3">&quot;alpha&quot;</span><span class="s1">, </span><span class="s3">&quot;beta&quot;</span><span class="s1">],</span>
    <span class="s1">coords={</span><span class="s3">&quot;cell_type&quot;</span><span class="s1">: results.posterior.coords[</span><span class="s3">&quot;cell_type_nb&quot;</span><span class="s1">]},</span>
<span class="s1">)</span>
<span class="s1">plt.show()</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">After refering to https://python.arviz.org/en/0.14.0/getting_started/Introduction.html, 
 
The trace plots generated for the parameters &quot;alpha&quot; and &quot;beta&quot; provide a visual representation of the posterior distributions from the Bayesian model. These plots show the sampled values over the course of the MCMC iterations, allowing us to assess the convergence and mixing of the chains. A well-mixed chain indicates that the model has likely converged to the true posterior distribution, while any signs of non-convergence, such as wandering or clumping in the trace, may require further investigation. For &quot;alpha&quot; and &quot;beta&quot;, we can observe whether their distributions are symmetric, skewed, or multimodal, which provides insight into the uncertainty of these parameters. Additionally, examining the Effective Sample Size (ESS) and potential autocorrelation within the trace helps ensure that the samples are independent and representative of the posterior. If the chains show good mixing and the distribution appears stable, we can be more confident that the model has accurately captured the uncertainty around the parameters. The lack of divergences further suggests that the model has been well-posed and that the parameter estimates for &quot;alpha&quot; and &quot;beta&quot; are reliable. 
</span></pre>
</body>
</html>
